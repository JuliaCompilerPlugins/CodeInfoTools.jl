var documenterSearchIndex = {"docs":
[{"location":"#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"","page":"API Documentation","title":"API Documentation","text":"Below is the API documentation for CodeInfoTools.jl","category":"page"},{"location":"","page":"API Documentation","title":"API Documentation","text":"CurrentModule = CodeInfoTools","category":"page"},{"location":"#Utilities","page":"API Documentation","title":"Utilities","text":"","category":"section"},{"location":"","page":"API Documentation","title":"API Documentation","text":"code_info\nwalk\nget_slot\ncode_inferred","category":"page"},{"location":"#CodeInfoTools.code_info","page":"API Documentation","title":"CodeInfoTools.code_info","text":"code_info(f::Function, tt::Type{T}; generated = true, debuginfo = :default) where T <: Tuple\ncode_info(f::Function, t::Type...; generated = true, debuginfo = :default)\n\nReturn lowered code for function f with tuple type tt. Equivalent to InteractiveUtils.@code_lowered – but a function call and requires a tuple type tt as input.\n\n\n\n\n\n","category":"function"},{"location":"#CodeInfoTools.walk","page":"API Documentation","title":"CodeInfoTools.walk","text":"walk(fn::Function, x)\n\nA generic dispatch-based tree-walker which applies fn::Function to x, specialized to Code node types (like Core.ReturnNode, Core.GotoNode, Core.GotoIfNot, etc). Applies fn::Function to sub-fields of nodes, and then zips the result back up into the node.\n\n\n\n\n\n","category":"function"},{"location":"#CodeInfoTools.get_slot","page":"API Documentation","title":"CodeInfoTools.get_slot","text":"get_slot(ci::CodeInfo, s::Symbol)\n\nGet the Core.Compiler.SlotNumber associated with the s::Symbol in ci::CodeInfo. If there is no associated Core.Compiler.SlotNumber, returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"#CodeInfoTools.code_inferred","page":"API Documentation","title":"CodeInfoTools.code_inferred","text":"code_inferred(@nospecialize(f), t::Type...; \n        world = Base.get_world_counter(),\n        interp = Core.Compiler.NativeInterpreter(world))\n\nDerives a Core.MethodInstance specialization for signature Tuple{typeof(f), t::Type...} and infers it with interp. Can be used to derive inferred lowered code with custom interpreters, either as parts of custom compilation pipelines or for debugging purposes.\n\ncode_inferred includes explicit checks which prevent the user from inadvertedly running inference multiple times on the same cached Core.CodeInfo associated with the specialization.\n\nwarning: Warning\nInference and optimization are stateful – if you try to do \"dumb\" things like grab the inferred Core.CodeInfo, wipe it, and shove it through lambda ... it is highly unlikely to work and very likely to explode in your face.Inference also caches the inferred Core.CodeInfo associated with the Core.MethodInstance specialization irrespective of the interpreter. That means (at least as far as I know at this time) you can't quickly infer with multiple interpreters without forcing a cache invalidation in between inference runs.\n\n\n\n\n\n","category":"function"},{"location":"#Working-with-Core.CodeInfo","page":"API Documentation","title":"Working with Core.CodeInfo","text":"","category":"section"},{"location":"","page":"API Documentation","title":"API Documentation","text":"Variable\nStatement\nCanvas\nBuilder\nslot!\nreturn!\niterate\nverify\nfinish","category":"page"},{"location":"#CodeInfoTools.Variable","page":"API Documentation","title":"CodeInfoTools.Variable","text":"const Variable = Core.SSAValue\nvar(id::Int) = Variable(id)\n\nAlias for Core.SSAValue – represents a primitive register in lowered code. See the section of Julia's documentation on lowered forms for more information.\n\n\n\n\n\n","category":"type"},{"location":"#CodeInfoTools.Statement","page":"API Documentation","title":"CodeInfoTools.Statement","text":"struct Statement{T}\n    node::T\n    type::Any\nend\n\nA wrapper around Core nodes with an optional type field to allow for user-based local propagation and other forms of analysis. Usage of Builder or Canvas will automatically wrap or unwrap nodes when inserting or calling finish – so the user should never see Statement instances directly unless they are working on type propagation.\n\nFor more information on Core nodes, please see Julia's documentation on lowered forms.\n\n\n\n\n\n","category":"type"},{"location":"#CodeInfoTools.Canvas","page":"API Documentation","title":"CodeInfoTools.Canvas","text":"struct Canvas\n    defs::Vector{Tuple{Int, Int}}\n    code::Vector{Any}\n    codelocs::Vector{Int32}\nend\nCanvas() = Canvas(Tuple{Int, Int}[], [], Int32[])\n\nA Vector-like abstraction for Core code nodes.\n\nProperties to keep in mind:\n\nInsertion anywhere is slow.\nPushing to beginning is slow.\nPushing to end is fast.\nDeletion is fast. \nAccessing elements is fast.\nSetting elements is fast.\n\nThus, if you build up a Canvas instance incrementally, everything should be fast.\n\n\n\n\n\n","category":"type"},{"location":"#CodeInfoTools.Builder","page":"API Documentation","title":"CodeInfoTools.Builder","text":"Builder(ci::Core.CodeInfo)\nBuilder(fn::Function, t::Type...)\nBuilder()\n\nA wrapper around a Canvas instance. Call finish when done to produce a new CodeInfo instance.\n\n\n\n\n\n","category":"type"},{"location":"#CodeInfoTools.slot!","page":"API Documentation","title":"CodeInfoTools.slot!","text":"slot!(b::Builder, name::Symbol; arg = false)::Core.SlotNumber\n\nAdd a new Core.SlotNumber with associated name::Symbol to the in-progress Core.CodeInfo on the c::Canvas inside b::Builder. If arg == false, also performs a pushfirst! with a Core.NewvarNode for consistency in the in-progress Core.CodeInfo. (arg controls whether or not we interpreter the new slot as an argument)\n\nname::Symbol must not already be associated with a Core.SlotNumber.\n\n\n\n\n\n","category":"function"},{"location":"#CodeInfoTools.return!","page":"API Documentation","title":"CodeInfoTools.return!","text":"return!(b::Builder, v::Variable)\nreturn!(b::Builder, v::NewVariable)\n\nPush a Core.ReturnNode to the current end of b.to::Canvas. Requires that the user pass in a v::Variable or v::NewVariable instance – so perform the correct unpack/tupling before creating a Core.ReturnNode.\n\n\n\n\n\n","category":"function"},{"location":"#Base.iterate","page":"API Documentation","title":"Base.iterate","text":"iterate(b::Builder, (ks, i) = (pipestate(p.from), 1))\n\nIterate over the original CodeInfo and add statements to a target Canvas held by b::Builder. iterate builds the Canvas in place – it also resolves local GlobalRef instances to their global values in-place at the function argument (the 1st argument) of Expr(:call, ...) instances. iterate is the key to expressing idioms like:\n\nfor (v, st) in b\n    b[v] = swap(st)\nend\n\nAt each step of the iteration, a new node is copied from the original CodeInfo to the target Canvas – and the user is allowed to setindex!, push!, or otherwise change the target Canvas before the next iteration. The naming of Core.SSAValues is taken care of to allow this.\n\n\n\n\n\n","category":"function"},{"location":"#CodeInfoTools.verify","page":"API Documentation","title":"CodeInfoTools.verify","text":"verify(src::Core.CodeInfo)\n\nValidate Core.CodeInfo instances using Core.Compiler.verify. Also explicitly checks that the linetable in src::Core.CodeInfo is not empty.\n\n\n\n\n\n","category":"function"},{"location":"#CodeInfoTools.finish","page":"API Documentation","title":"CodeInfoTools.finish","text":"finish(b::Builder)\n\nCreate a new CodeInfo instance from a Builder. Renumbers the wrapped Canvas in-place – then copies information from the original CodeInfo instance and inserts modifications from the wrapped Canvas\n\n\n\n\n\n","category":"function"},{"location":"#Evaluation","page":"API Documentation","title":"Evaluation","text":"","category":"section"},{"location":"","page":"API Documentation","title":"API Documentation","text":"lambda","category":"page"},{"location":"#CodeInfoTools.lambda","page":"API Documentation","title":"CodeInfoTools.lambda","text":"warning: Warning\nIt is relatively difficult to prevent the user from shooting themselves in the foot with this sort of functionality. Please be aware of this. Segfaults should be cautiously expected.\n\nlambda(m::Module, src::Core.CodeInfo)\nlambda(m::Module, src::Core.CodeInfo, nargs::Int)\nconst λ = lambda\n\nCreate an anonymous @generated function from a piece of src::Core.CodeInfo. The src::Core.CodeInfo is checked for consistency by verify.\n\nlambda has a 2 different forms. The first form, given by signature:\n\nlambda(m::Module, src::Core.CodeInfo)\n\ntries to detect the correct number of arguments automatically. This may fail (for any number of internal reasons). Expecting this, the second form, given by signature:\n\nlambda(m::Module, src::Core.CodeInfo, nargs::Int)\n\nallows the user to specify the number of arguments via nargs.\n\nlambda also has the shorthand λ for those lovers of Unicode.\n\n\n\n\n\n","category":"function"},{"location":"motivation/#Motivation","page":"Motivation","title":"Motivation","text":"","category":"section"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"note: Note\nFollow along with the REPL.","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"Working with Core.CodeInfo is often not fun. E.g. when examining the untyped lowered form of the Rosenbrock function","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"CodeInfo(\n1 ─ %1  = a - x\n│   %2  = Core.apply_type(Base.Val, 2)\n│   %3  = (%2)()\n│   %4  = Base.literal_pow(Main.CodeInfoToolsTour.:^, %1, %3)\n│   %5  = Core.apply_type(Base.Val, 2)\n│   %6  = (%5)()\n│   %7  = Base.literal_pow(Main.CodeInfoToolsTour.:^, x, %6)\n│   %8  = y - %7\n│   %9  = Core.apply_type(Base.Val, 2)\n│   %10 = (%9)()\n│   %11 = Base.literal_pow(Main.CodeInfoToolsTour.:^, %8, %10)\n│   %12 = b * %11\n│   %13 = %4 + %12\n└──       return %13\n)","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"Do you ever wonder – is there another (perhaps, any) way to work with this object? A Builder perhaps? Where I might load my CodeInfo into – iterate, make local changes, and produce a new copy?","category":"page"},{"location":"motivation/#Contribution","page":"Motivation","title":"Contribution","text":"","category":"section"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"CodeInfoTools.jl provides a Builder abstraction (amongst a few other nifty tools) which allows you to safely iterate over and manipulate Core.CodeInfo. It also provides more advanced functionality for creating and evaluating Core.CodeInfo – which is a bit on the experimental side.","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"How might you use this in practice?","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"using CodeInfoTools\n\nrosenbrock(a, b, x, y) = (a - x)^2 + b * (y - x^2)^2\n\ndisplay(code_inferred(rosenbrock, Int, Int, Int, Int))\n\nfunction swap(st)\n    st isa Expr || return st\n    st.head == :call || return st\n    st.args[1] == Base.:(+) || return st\n    return Expr(:call, Base.:(*), st.args[2:end]...)\nend\n\nfunction transform(src)\n    b = CodeInfoTools.Builder(src)\n    for (v, st) in b\n        b[v] = swap(st)\n    end\n    return finish(b)\nend\n\nsrc = code_info(rosenbrock, Int, Int, Int, Int)\nnew = transform(src)\n\ndisplay(src)\ndisplay(new)","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"Here, we've lowered a function directly to a Core.CodeInfo instance and created a Builder instance b. You can now safely iterate over this object, perform local changes, press finish and - (la di da!) - out comes a new Core.CodeInfo with your changes fresh.","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"CodeInfo(\n    @ /Users/mccoybecker/dev/CodeInfoTools.jl/examples/tour.jl:5 within `rosenbrock'\n1 ─ %1  = (-)(a, x)\n│   %2  = (Core.apply_type)(Val, 2)\n│   %3  = (%2)()\n│   %4  = (Base.literal_pow)(^, %1, %3)\n│   %5  = (Core.apply_type)(Val, 2)\n│   %6  = (%5)()\n│   %7  = (Base.literal_pow)(^, x, %6)\n│   %8  = (-)(y, %7)\n│   %9  = (Core.apply_type)(Val, 2)\n│   %10 = (%9)()\n│   %11 = (Base.literal_pow)(^, %8, %10)\n│   %12 = (*)(b, %11)\n│   %13 = (*)(%4, %12)\n└──       return %13\n)","category":"page"}]
}
