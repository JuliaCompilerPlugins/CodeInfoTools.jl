var documenterSearchIndex = {"docs":
[{"location":"#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"","page":"API Documentation","title":"API Documentation","text":"Below is the API documentation for CodeInfoTools.jl","category":"page"},{"location":"","page":"API Documentation","title":"API Documentation","text":"CurrentModule = CodeInfoTools","category":"page"},{"location":"#Utilities","page":"API Documentation","title":"Utilities","text":"","category":"section"},{"location":"","page":"API Documentation","title":"API Documentation","text":"code_info\nwalk\nget_slot","category":"page"},{"location":"#CodeInfoTools.code_info","page":"API Documentation","title":"CodeInfoTools.code_info","text":"code_info(f::Function, tt::Type{T}; generated = true, debuginfo = :default) where T <: Tuple\ncode_info(f::Function, t::Type...; generated = true, debuginfo = :default)\n\nReturn lowered code for function f with tuple type tt. Equivalent to InteractiveUtils.@code_lowered – but a function call and requires a tuple type tt as input.\n\n\n\n\n\n","category":"function"},{"location":"#CodeInfoTools.walk","page":"API Documentation","title":"CodeInfoTools.walk","text":"walk(fn::Function, x)\n\nA generic dispatch-based tree-walker which applies fn::Function to x, specialized to Code node types (like Core.ReturnNode, Core.GotoNode, Core.GotoIfNot, etc). Applies fn::Function to sub-fields of nodes, and then zips the result back up into the node.\n\n\n\n\n\n","category":"function"},{"location":"#CodeInfoTools.get_slot","page":"API Documentation","title":"CodeInfoTools.get_slot","text":"get_slot(ci::CodeInfo, s::Symbol)\n\nGet the Core.Compiler.SlotNumber associated with the s::Symbol in ci::CodeInfo. If there is no associated Core.Compiler.SlotNumber, returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"#Working-with-CodeInfo","page":"API Documentation","title":"Working with CodeInfo","text":"","category":"section"},{"location":"","page":"API Documentation","title":"API Documentation","text":"Variable\nStatement\nCanvas\nBuilder\nslot!\niterate\nverify\nfinish","category":"page"},{"location":"#CodeInfoTools.Variable","page":"API Documentation","title":"CodeInfoTools.Variable","text":"const Variable = Core.SSAValue\nvar(id::Int) = Variable(id)\n\nAlias for Core.SSAValue – represents a primitive register in lowered code. See the section of Julia's documentation on lowered forms for more information.\n\n\n\n\n\n","category":"type"},{"location":"#CodeInfoTools.Statement","page":"API Documentation","title":"CodeInfoTools.Statement","text":"struct Statement{T}\n    node::T\n    type::Any\nend\n\nA wrapper around Core nodes with an optional type field to allow for user-based local propagation and other forms of analysis. Usage of Builder or Canvas will automatically wrap or unwrap nodes when inserting or calling finish – so the user should never see Statement instances directly unless they are working on type propagation.\n\nFor more information on Core nodes, please see Julia's documentation on lowered forms.\n\n\n\n\n\n","category":"type"},{"location":"#CodeInfoTools.Canvas","page":"API Documentation","title":"CodeInfoTools.Canvas","text":"struct Canvas\n    defs::Vector{Tuple{Int, Int}}\n    code::Vector{Any}\n    codelocs::Vector{Int32}\nend\nCanvas() = Canvas(Tuple{Int, Int}[], [], Int32[])\n\nA Vector-like abstraction for Core code nodes.\n\nProperties to keep in mind:\n\nInsertion anywhere is slow.\nPushing to beginning is slow.\nPushing to end is fast.\nDeletion is fast. \nAccessing elements is fast.\nSetting elements is fast.\n\nThus, if you build up a Canvas instance incrementally, everything should be fast.\n\n\n\n\n\n","category":"type"},{"location":"#CodeInfoTools.Builder","page":"API Documentation","title":"CodeInfoTools.Builder","text":"Builder(ir)\n\nA wrapper around a Canvas instance. Call finish when done to produce a new CodeInfo instance.\n\n\n\n\n\n","category":"type"},{"location":"#CodeInfoTools.slot!","page":"API Documentation","title":"CodeInfoTools.slot!","text":"slot!(b::Builder, name::Symbol)::Core.SlotNumber\n\nAdd a new Core.SlotNumber with associated name::Symbol to the in-progress Core.CodeInfo on the c::Canvas inside b::Builder. Also performs a pushfirst! with a Core.NewvarNode for consistency in the in-progress Core.CodeInfo.\n\nname::Symbol must not already be associated with a Core.SlotNumber.\n\n\n\n\n\n","category":"function"},{"location":"#Base.iterate","page":"API Documentation","title":"Base.iterate","text":"iterate(b::Builder, (ks, i) = (pipestate(p.from), 1))\n\nIterate over the original CodeInfo and add statements to a target Canvas held by b::Builder. iterate builds the Canvas in place – it also resolves local GlobalRef instances to their global values in-place at the function argument (the 1st argument) of Expr(:call, ...) instances. iterate is the key to expressing idioms like:\n\nfor (v, st) in b\n    b[v] = swap(st)\nend\n\nAt each step of the iteration, a new node is copied from the original CodeInfo to the target Canvas – and the user is allowed to setindex!, push!, or otherwise change the target Canvas before the next iteration. The naming of Core.SSAValues is taken care of to allow this.\n\n\n\n\n\n","category":"function"},{"location":"#CodeInfoTools.verify","page":"API Documentation","title":"CodeInfoTools.verify","text":"verify(src::Core.CodeInfo)\n\nValidate Core.CodeInfo instances using Core.Compiler.verify. Also explicitly checks that the linetable in src::Core.CodeInfo is not empty.\n\n\n\n\n\n","category":"function"},{"location":"#CodeInfoTools.finish","page":"API Documentation","title":"CodeInfoTools.finish","text":"finish(b::Builder)\n\nCreate a new CodeInfo instance from a Builder. Renumbers the wrapped Canvas in-place – then copies information from the original CodeInfo instance and inserts modifications from the wrapped Canvas\n\n\n\n\n\n","category":"function"},{"location":"#Evaluation","page":"API Documentation","title":"Evaluation","text":"","category":"section"},{"location":"","page":"API Documentation","title":"API Documentation","text":"lambda","category":"page"},{"location":"#CodeInfoTools.lambda","page":"API Documentation","title":"CodeInfoTools.lambda","text":"lambda(m::Module, src::Core.CodeInfo)\nlambda(m::Module, src::Core.CodeInfo, nargs::Int)\nconst λ = lambda\n\nCreate an anonymous @generated function from a piece of src::Core.CodeInfo. The src::Core.CodeInfo is checked for consistency by verify.\n\nlambda has a 2 different forms. The first form, given by signature:\n\nlambda(m::Module, src::Core.CodeInfo)\n\ntries to detect the correct number of arguments automatically. This may fail (for any number of internal reasons). Expecting this, the second form, given by signature:\n\nlambda(m::Module, src::Core.CodeInfo, nargs::Int)\n\nallows the user to specify the number of arguments via nargs.\n\nNote: it is relatively difficult to prevent the user from shooting themselves in the foot with this sort of functionality. Please be aware of this. Segfaults should be cautiously expected.\n\n\n\n\n\n","category":"function"}]
}
